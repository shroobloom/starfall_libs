--@name Projectile
--@author shroobloom
--@server
--@include sb/util.txt
--@include sb/spawner.txt



local Util = require("sb/util.txt")
local Spawner = require("sb/spawner.txt")


local Projectile = class("Projectile")
Projectile.Instances = {}



--TODO:
-- [ ] Missiles should lose their target if they die, also, they'd try to go back to their LaunchAngle, which is bad.
-- [X] Arc mode, they should do a big arc to reach their target if this is on
-- [X] A ThrustMax and ThrustRampupTime variable to allow the rockets to move faster the longer they're alive for
-- [X] Projectiles should have a Lifetime property, and explode (or lose fuel?) after they live for long enough
-- [X] Projectiles should allow for multiple explosives to detonate
-- [ ] Sometimes guidance screws up and causes the missile to loop around. this is not a quirk of wobble, its likely only when its going straight down and has to change yaw
-- [~] Fix delta silo to not be explosion ratelimited


local PropertyDefaults = {
    Model = "models/props_c17/canister02a.mdl",
    ModelAngle = Angle(90,0,0),
    
    Enabled = true,
    
    -- Initial velocity - the projectile will have this velocity on launch
    -- The max speed for a projectile is equal to physenv.getPerformanceSettings().MaxVelocity, which is ~2966 at the time of writing on CFC.
    Speed = 0,
    
    -- Constant thrust - the projectile will try to maintain this speed
    Thrust = 0,
    
    -- Maximum thrust and thrust rampup - the projectile will slowly ramp up to this thrust level as it's existed for up to its rampup time
    -- Similar to how the LFS Rocket Launcher will speed up as it's been chasing the target for longer. Good for versatile weapons.
    ThrustMax = nil,
    ThrustRampupTime = 10,
    
    Gravity = true,
    
    ExplosionEffect = "lfs_missile_explosion",
    
    Trail = {
        Material = "", --trails/smoke
        StartSize = 10,
        EndSize = 75,
        Length = 0.25, --Duration
        Color = Color(255,255,255),
        Additive = false
    },
    
    Wobble = {
        Speed = 0,
        Power = 0
    },
    
    Homing = {
        TurnForce = 0 --TODO: implement
    },
    
    -- If true, the projectile will turn to face its current velocity
    -- Has no effect on homing projectiles.
    FinStabilized = true,
    
    -- If set, causes the missiles to curve to their target instead of flying directly at them at a specific height.
    ArcHeight = nil,
    
    -- After this duration, the projectile will self-destruct
    Lifetime = 30,
    
    -- The number of supplementary explosives to spawn
    ExplosionPower = 0
}



function Projectile:initialize( pos, ang, properties )
    
    Util.applyDefaults( properties, PropertyDefaults )
    
    for i,v in pairs(properties) do
        self[i] = v
    end
    
    
    self.Instance = prop.create( pos, ang + properties.ModelAngle, properties.Model, false )
    self.Instance:enableDrag( false )
    self.Instance:enableGravity( properties.Gravity )
    self.Instance:doNotDuplicate()
    self.Instance:setMass(1) --just so impacts dont kill
    
    self.Instance.Projectile = self
    
    self.Detonated = false
    self.Target = nil --Either a Vector or an Entity
    
    --TODO: configuration
    self.WobbleSeed = math.random()*math.pi
    self.WobbleDir = math.sign(math.random()-0.5)
    self.Ready = self.ExplosionPower == 0
    
    if properties.Enabled then
        self.Enabled = false
        self:fire()
    end
    
    self.SupplementaryExplosives = {}
    
    if self.ExplosionPower > 0 then
        Util.spawn(function()
            local toSpawn = self.ExplosionPower
            
            while toSpawn > 0 do
                Spawner.Await()
                if not self:isValid() then break end
                
                pcall(function()
                    -- can't use self.Instance:getModel() because of the explosion ratelimiter, which is 5x more lenient on explosive
                    -- barrels for some reason, so thats what we'll use (at the cost of a bit of AoE)
                    local sup = prop.create( Vector(), Angle(), "models/props_c17/oildrum001_explosive.mdl", true )
                    sup:setNoDraw(true)
                    sup:setSolid(false)
                    sup:setNocollideAll(true)
                    sup:setCollisionGroup(COLLISION_GROUP.IN_VEHICLE)
                    
                    table.insert(self.SupplementaryExplosives, sup)
                    
                    toSpawn = toSpawn - 1
                end)
            end
            
            self.Ready = true
        end)
    end
    
    table.insert(Projectile.Instances, self)
    
end




function Projectile:fire()
    assert(not self.Enabled, "Projectile has already been fired!")
    
    if isValid(self:getParent()) then
        self:setParent( nil )
    end
    
    if self:isFrozen() then
        self:setFrozen( false )
    end
    
    self.LaunchTime = timer.curtime()
    self.LaunchPos = self.Instance:getPos()
    self.LaunchAngle = self.Instance:getAngles() - self.ModelAngle
    self.Enabled = true
    
    self.Instance:applyForceCenter( self:getForward() * self.Speed * self.Instance:getMass() )
    
    if self.Trail.Material ~= "" then
        self.Instance:setTrails(self.Trail.StartSize, self.Trail.EndSize, self.Trail.Length, self.Trail.Material, self.Trail.Color, nil, self.Trail.Additive)
    end
    
    self.Instance:addCollisionListener(function( hit )
        if self.Detonated or hit.HitEntity.Projectile then return end
        self:detonate( nil, hit )
    end)
end


function Projectile:getTargetPos()
    return type(self.Target) == "Vector" and self.Target or self.Target:obbCenterW()
end


function Projectile:setFrozen( state )
    self.Instance:setFrozen( state )
end

function Projectile:isFrozen()
    return self.Instance:isFrozen()
end

function Projectile:setParent( ent )
    self.Instance:setParent( ent )
end

function Projectile:getParent()
    return self.Instance:getParent()
end



function Projectile:getForward()
    return self.Instance:localToWorldVector( self.ModelAngle:getForward() )
end


-- Runs 10 times/s to allow for a ton of projectiles and still being performant
function Projectile:think()
    if not self.Enabled then return end
    
    if type(self.Target) ~= "Vector" and not isValid(self.Target) then
        self.Target = nil
    end
    
    if timer.curtime() - self.LaunchTime > self.Lifetime then
        return self:detonate()
    end
    
    if self.Thrust > 0 then
        local curThrust = self.Thrust
        
        if self.MaxThrust then
            local accel = math.clamp((timer.curtime() - self.LaunchTime) / self.ThrustRampupTime, 0, 1)
            curThrust = math.lerp(accel, self.Thrust, self.MaxThrust or self.Thrust)
        end
        
        
        self.Instance:applyForceCenter( (self:getForward()*curThrust - self.Instance:getVelocity()*1) * self.Instance:getMass() )
    end
    
    
    
    local targetAngle = self.LaunchAngle
    
    if self.Target then
        local targetPos = self:getTargetPos()
        
        if self.ArcHeight then
            local tpz0 = targetPos:clone():setZ(0)
            local lpz0 = self.LaunchPos:clone():setZ(0)
            
            local startDist = tpz0:getDistance(lpz0)
            local currentDist = tpz0:getDistance( self.Instance:getPos():setZ(0) )
            local alpha = 1 - math.clamp(currentDist / startDist, 0, 1)
            local mid = (self.LaunchPos + targetPos)/2
            mid:setZ( math.max(self.LaunchPos.z, targetPos.z) + self.ArcHeight )
            
            targetPos = math.bezierVector( alpha + 0.1, self.LaunchPos, mid, targetPos )
        end
        
        targetAngle = (targetPos - self.Instance:getPos()):getAngle()
    elseif self.FinStabilized then
        targetAngle = self.Instance:getVelocity():getAngle()
    end
    
    if self.Wobble.Frequency ~= 0 then
        targetAngle = targetAngle + Angle(
            math.sin( timer.curtime()*math.pi*self.Wobble.Speed*self.WobbleDir + self.WobbleSeed )*self.Wobble.Power,
            math.cos( timer.curtime()*math.pi*self.Wobble.Speed*self.WobbleDir + self.WobbleSeed )*self.Wobble.Power,
            0
        ) * math.min( (timer.curtime() - self.LaunchTime), 1 )
    end
    
    
    if targetAngle ~= self.LaunchAngle then
        local inertiaVec = self.Instance:getInertia()
        local inertia = Angle( inertiaVec.y, inertiaVec.z, inertiaVec.x )
        
        local localAng = self.Instance:worldToLocalAngles(targetAngle)
        localAng.p = math.clamp(localAng.p, -15, 15)
        localAng.y = math.clamp(localAng.y, -15, 15)
        
        self.Instance:applyAngForce( (localAng*200 - self.Instance:getAngleVelocityAngle()*30) * inertia )
    end
    
end



--[[ Explosion ratelimit patcher ]]--

Projectile.NextDetonation = {}
Projectile.EXPLOSION_RATELIMIT = {
    ["models/props_phx/oildrum001_explosive.mdl"] = 0.1,
    ["models/props_c17/oildrum001_explosive.mdl"] = 0.1
}

--TODO: make sure server UUID doesnt change with restarts/addon changes
local IS_CFC = wire.serverUUID() == "1c17c305-2132-4428-840e-3f4cb52f9705"
local BLAST_RADIUS = 180

local function canDetonate( ent )
    return not IS_CFC or timer.curtime() > (Projectile.NextDetonation[ent:getModel()] or 0)
end

-- Breaks a prop while tagging you for the kill credit
-- Also will not explosion ratelimit you, at the cost of not tagging your kills.
local function taggedBreak( ent, forceTag )
    local mdl = ent:getModel()
    local wasTagged = false
    
    if IS_CFC then
        -- Don't tag if the ratelimiter is on cooldown
        if canDetonate( ent ) then
            local actuallyTag = forceTag
            
            -- only tag if its near a player
            if not actuallyTag then
                for i,v in pairs(find.allPlayers()) do
                    if v:isAlive() and v:isInPvp() and v:getPos():getDistance( ent:getPos() ) < BLAST_RADIUS then
                        actuallyTag = true
                        break
                    end
                end
            end
            
            -- okay search for NPCs next
            if not actuallyTag then
                for i,v in pairs(find.byClass("npc_*")) do
                    if v:getHealth() > 0 and v:getPos():getDistance( ent:getPos() ) < BLAST_RADIUS then
                        actuallyTag = true
                        break
                    end
                end
            end
            
            
            if actuallyTag then
                ent:applyDamage(10, owner(), owner(), DAMAGE.BLAST)
                Projectile.NextDetonation[ent:getModel()] = timer.curtime() + (Projectile.EXPLOSION_RATELIMIT[mdl] or 0.5)
                wasTagged = true
            end
        end
    else
        ent:applyDamage(10, owner(), owner(), DAMAGE.BLAST)
        wasTagged = true
    end
    
    ent:breakEnt()
    
    return wasTagged
end




function Projectile:detonate( dontBreak, collision )
    if self.Detonated then return end
    
    self.Enabled = false
    self.Detonated = true
    
    local shouldForceTag = collision and isValid(collision.HitEntity) and not collision.HitEntity:isFrozen()
    
    if self.ExplosionPower > 0 then
        Util.spawn(function()
            local origin = self.Instance:getPos()
            local radius = 50*math.sqrt(self.ExplosionPower)
            local normal = collision and collision.HitNormal or Vector(0,0,1)
            
            for i,v in pairs(self.SupplementaryExplosives) do
                if not isValid(v) then continue end
                
                local a = math.random()*360
                local p = origin + Angle():rotateAroundAxis(normal, a):getForward()*(math.random(20, radius))
                
                v:setParent(nil)
                v:setPos(p)
                
                local tagged = taggedBreak(v, shouldForceTag)
                
                -- wait 0.1s for the explosion ratelimiter
                -- why does this even exist :despair:
                if tagged then
                    Util.wait(0.1)
                end
            end
        end)
    end
    
    if isValid(self.Instance) and not dontBreak then
        taggedBreak( self.Instance, shouldForceTag )
    end
    
    if self.ExplosionEffect ~= "" and effect.canCreate() then
        local ef = effect.create()
        ef:setOrigin(self.Instance:getPos())
        ef:play(self.ExplosionEffect)
    end
    
    table.removeByValue(Projectile.Instances, self)
end


function Projectile:isValid()
    return isValid(self.Instance)
end


function Projectile:remove()
    if isValid(self.Instance) then
        self.Instance:remove()
        self.Detonated = true
    end
    
    self.Enabled = false
    
    table.removeByValue(Projectile.Instances, self)
end




timer.create("Projectile_Think", 0.1, 0, function()
    for i,v in pairs(Projectile.Instances) do
        v:think()
    end
end)


hook.add("EntityRemoved", "Projectile_Removal", function( e )
    if not e.Projectile then return end
    e.Projectile:detonate( true )
end)




return Projectile

