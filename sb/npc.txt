--@name NPC Utils
--@author shroobloom
--@server
--@include sb/spawner.txt
--@include sb/e2vm.txt
--@include sb/util.txt



local Spawner = require("sb/spawner.txt")
local E2VM = require("sb/e2vm.txt")
local Util = require("sb/util.txt")



local NPC = {}



--[[ CONFIG ]]--

-- Base Spawn Cap
-- Example: SpawnCap = 20
-- At 1 participant, the cap will be 20
-- At 2 participants, the cap would be 20*log2(2+1) = 31
-- At 3 participants, the cap would be 40
-- At 7, the cap is 80, and so on.
NPC.SpawnCap = 20

-- Range: How far away NPCs can spawn from the player
NPC.SpawnDistance = {800, 3000}

-- How many seconds of inactivity (not having a target) before NPCs despawn
NPC.DespawnTime = 60

-- Enables certain debug features
NPC.Debug = false

-- Decides whether or not NPCs need their spawn point's LoS blocked. (set to true for better immersion)
NPC.SpawnOutOfSight = true

-- How far mobile spawnpoints ("beacons") protect in a radius
NPC.BeaconWardDistance = 2000

-- Self-explanatory
NPC.DamageMultiplier = 1
NPC.WeaponProficiency = 3



-- Constants
local HUMANOID_BOX_SIZE = Vector(32,32,72)



local BullseyeMaker = E2VM:new([[
@name [VM] Bullseye Maker
@inputs Pos:vector
@outputs Bullseye:entity
@trigger Pos

propSpawnUndo(0)

if (Pos) {
    Bullseye = entSpawn( "npc_bullseye", Pos )
}
]])


function makeBullseye( pos )
    BullseyeMaker:fireInput("Pos", pos)
    local bullseye = BullseyeMaker:getOutput("Bullseye")
    bullseye:setNocollideAll(true)
    
    return bullseye
end




-- Anything that can prevent spawning
local Beacons = find.byClass("sent_spawnpoint")


hook.add("OnEntityCreated", "RegisterBeacon", function( e )
    if not isValid(e) or e:getClass() ~= "sent_spawnpoint" then return end
    table.insert(Beacons, e)
end)

hook.add("EntityRemoved", "RemoveBeacon", function( e )
    if e:getClass() ~= "sent_spawnpoint" then return end
    table.removeByValue(Beacons, e)
end)




NPC.Participants = {}
NPC.Instances = {}



hook.add("PlayerDisconnected", "RemoveParticipant", function(e)
    table.removeByValue(NPC.Participants, e)
end)



NPC.Types = {
    --[[ Ports ]]--
    ["Soldier"] = {
        Name = "Combine Soldier",
        Class = "npc_combine_s",
        Weapons = {"smg1", "ar2"},
        Health = 50,
        
        Squad = {
            {"Soldier", 2, 3}
        }
    },
    ["Elite"] = {
        Name = "Combine Elite",
        Class = "CombineElite",
        Weapons = {"ar2"},
        Health = 150,
        
        Squad = {
            {"Soldier", 0, 3},
            {"Elite", 0, 2}
        }
    },
    ["Shotgunner"] = {
        Name = "Combine Shotgunner",
        Class = "ShotgunSoldier",
        Weapons = {"shotgun"},
        Health = 65,
        Damage = 3
    },
    ["RoofTurret"] = {
        Name = "Combine Roof Turret",
        Class = "npc_turret_ceiling",
        Health = 300,
        Ceiling = true
    },
    ["Strider"] = {
        Name = "Combine Strider",
        Class = "npc_strider",
        Damage = 1,
        BoxSize = Vector(150, 150, 550),
        Offset = Vector(0,0,16),
        
        Indoors = false,
        
        Abilities = {
            {
                Cooldown = 20,
                Use = function( npc )
                    local Target = npc:getEnemy()
                    if not Target then return end
                    
                    local Bullseye = makeBullseye( Target:getPos() )
                    local LastPos = Bullseye:getPos()
                    
                    Bullseye:setMappingName("Target" .. Bullseye:entIndex())
                    npc:fireInput("SetCannonTarget", Bullseye:getMappingName())
                    
                    while true do
                        Util.wait()
                        
                        if not Bullseye:isValid() then
                            if effect.canCreate() then
                                local hit = trace.line( npc:getEyePos(), LastPos, npc )
                                
                                local boom = effect.create()
                                boom:setOrigin(hit.HitPos)
                                boom:play("lfs_explosion")
                            end
                            
                            break
                        end
                        
                        if not Target:isValid() or not Target:isAlive() then
                            Bullseye:remove() --interruption
                        else
                            Bullseye:setPos( Target:getPos() + Vector( math.sin(timer.curtime()*3.25), math.sin(timer.curtime()*2.425), (math.sin(timer.curtime()*1.06) + 1)*0.5 )*200 )
                            LastPos = Bullseye:getPos()
                        end
                    end
                    
                end
            }
        }
    },
    ["HunterChopper"] = {
        Name = "Hunter Chopper",
        Class = "npc_helicopter",
        Damage = 1,
        BoxSize = Vector(80, 80, 80),
        Offset = Vector(0,0,192),
        
        Indoors = false
    },
    ["Gunship"] = {
        Name = "Combine Gunship",
        Class = "npc_combinegunship",
        Damage = 1,
        BoxSize = Vector(80, 80, 80),
        Offset = Vector(0,0,192),
        
        Indoors = false
    },
    ["Manhack"] = {
        Name = "Manhack",
        Class = "npc_manhack",
        Damage = 2,
        BoxSize = Vector(24, 24, 24),
        Offset = Vector(0,0,16),
        
        Squad = {
            {"Manhack", 0, 5}
        }
    },
    
    --[[ Original Characters ]]--
    ["Captain"] = {
        Name = "Combine Captain",
        Class = "CombineElite",
        Material = "models/combine_soldier/combinesoldiersheet_shotgun",
        Weapons = {"ar2"},
        Health = 600,
        Damage = 3,
        Scale = 1.25,
        
        Squad = {
            {"Soldier", 2, 3},
            {"Shotgunner", 0, 2}
        }
    },
    ["Firefly"] = {
        Name = "Firefly Manhack",
        Class = "npc_manhack",
        Weapons = {"rpg"},
        Damage = 1,
        Proficiency = 4,
        Scale = 2,
        BoxSize = Vector(24, 24, 24),
        Offset = Vector(0,0,16)
    },
    ["Mosquito"] = {
        Name = "Mosquito Manhack",
        Class = "npc_manhack",
        Weapons = {"ar2"},
        Damage = 0.25,
        BoxSize = Vector(24, 24, 24),
        Offset = Vector(0,0,16),
        
        Squad = {
            {"Mosquito", 3, 6}
        }
    }
    
    --TODO: Engineer?
}





-- Gets a random NPC ID to spawn.
-- List should be formatted as an array of objects.

function NPC.pickSpawn( WeightedList )
    local MaxWeight = 0
    
    for i,v in pairs(WeightedList) do
        MaxWeight = MaxWeight + v.Weight
    end
    
    local c = math.random() * MaxWeight
    
    for i,v in pairs(WeightedList) do
        c = c - v.Weight
        
        if c <= 0 then
            return v.ID
        end
    end
end



function NPC.getMax()
    return math.round(NPC.SpawnCap*(math.log( #NPC.Participants, 2 ) + 1))
end




-- Gets a spawn location for the NPC
-- If a boolean is supplied, it will require the indoors value to be that.
-- For example, if you pass true, the NPC MUST spawn indoors. If you pass false, the NPC MUST spawn outdoors. If you pass nil, it'll spawn anywhere
-- There's not a 100% chance it'll succeed tho
function NPC.pickSpawnLocation( ID )
    
    local spawner = table.random(NPC.Participants)
    local data = NPC.Types[ID]
    
    
    --local radiusPos = spawner:getPos() + Vector(math.random()-0.5, math.random()-0.5, math.random()*0.25 - 0.125) * r * 2
    
    --[[ Sphere find ]]--
    local r = math.random(NPC.SpawnDistance[1], NPC.SpawnDistance[2])
    local lon = math.random()*2*math.pi
    local lat = (math.random()-0.5)*0.5*math.pi
    
    local radiusPos = spawner:getPos() + Vector(math.cos(lon)*math.cos(lat), math.sin(lon)*math.cos(lat), math.sin(lat)*0.5) * r * 2
    if not radiusPos:isInWorld() then return --[[print("out of world")]] end
    
    local zmul = data.Ceiling and -1 or 1
    
    -- Find the ground position
    -- TODO: dont count water as valid ground somehow
    local big = not data.BoxSize or data.BoxSize:getLengthSqr() > HUMANOID_BOX_SIZE:getLengthSqr()*2
    local obbSize = data.BoxSize or HUMANOID_BOX_SIZE
    
    local ground = big and 
        trace.hull( 
            radiusPos, 
            radiusPos - Vector(0,0,3000*zmul), 
            -obbSize*Vector(0.5,0.5,0)*(data.Scale or 1), 
            obbSize*Vector(0.5,0.5,0)*(data.Scale or 1)
        ) or trace.line( 
            radiusPos, 
            radiusPos - Vector(0,0,3000*zmul)
        )
    
    if not ground.Hit or ground.HitNonWorld or ground.HitNoDraw then return --[[print("no ground")]] end
    
    -- Make sure noone is too close
    local nearby = {}
    
    for i,v in pairs(NPC.Participants) do
        local d = v:getPos():getDistanceSqr( ground.HitPos )
        
        if d < NPC.SpawnDistance[1]^2 then
            return --print("too close")
        elseif d < (NPC.SpawnDistance[2]*1.5)^2 then
            table.insert(nearby, v)
        end
    end
    
    -- Make sure no beacons are too close
    for i,v in pairs(Beacons) do
        if v:getPos():getDistanceSqr( ground.HitPos ) < NPC.BeaconWardDistance^2 then
            return
        end
    end
    
    -- Make sure if there's an indoor/outdoor preference, it follows that
    if data.Indoors ~= nil and not data.Ceiling then
        local roof = trace.line( ground.HitPos, ground.HitPos + Vector(0,0,2000) )
        if roof.Hit ~= data.Indoors then return --[[print("its indoors")]] end
    end
    
    -- Make sure nothing is inside the NPC's bounding box
    if not data.Ceiling then
        local boundBoxHit = trace.hull( 
            ground.HitPos + (data.Offset or Vector()) + Vector(0,0,obbSize.z*(data.Scale or 1)), 
            ground.HitPos + (data.Offset or Vector()) + Vector(0,0,8), 
            -obbSize*Vector(0.5,0.5,0)*(data.Scale or 1), 
            obbSize*Vector(0.5,0.5,0)*(data.Scale or 1)
        )
        
        if boundBoxHit.Hit then
            --[[local h = hologram.create( ground.HitPos + (data.Offset or Vector())/2 + Vector(0,0,obbSize.z*(data.Scale or 1) + 8)/2, Angle(), "models/hunter/blocks/cube1x1x1.mdl" )
            h:setSize( obbSize*(data.Scale or 1) )
            h:setMaterial("models/debug/debugwhite")
            h:suppressEngineLighting(true)
            h:setColor(Color(255,0,0,144))]]
            return --print("bounds")
        end
    end
    
    -- Make sure theres no line of sight to anyone
    if NPC.SpawnOutOfSight then
        for i,v in pairs(nearby) do
            local losBlock = trace.line( v:getEyePos(), ground.HitPos + (Vector(0,0,obbSize.z * 0.9) + (data.Offset or Vector())), v, MASK.NPCWORLDSTATIC )
            if not losBlock.Hit then return --[[print("los")]] end
        end
    end
    
    return ground.HitPos, spawner
    
end




--[[
table.insert(NPC.Participants, owner())
local amt = 50
local success = 0

for i=1, amt do
    local p = NPC.pickSpawnLocation( "Strider" )
    
    if not p then
        continue
    end
    
    local p = hologram.create(p, Angle(), "models/hunter/blocks/cube05x05x05.mdl", Vector(1,1,1))
    
    success = success + 1
end


print("Generated " .. success .. " / " .. amt .. " spawns.")
]]




function NPC.shouldParticipate( plr )
    return plr:isInPvp() and not plr:isNoclipped() and not plr:hasGodMode() and plr:isAlive()
end






function NPC.spawn( pos, ID, squadLeader )
    local data = NPC.Types[ID]
    
    local npc = prop.createSent( pos + (data.Offset or Vector(0,0,8)), Angle(0,math.random()*360,0), data.Class, false )
    table.insert(NPC.Instances, npc)
    
    npc.LastSighted = timer.curtime()
    npc.IsChipNPC = true
    npc.ID = ID
    
    if data.Weapons and #data.Weapons > 0 then
        npc:giveWeapon( table.random(data.Weapons) )
    end
    
    npc:setMaxHealth( data.Health or 50 )
    npc:setHealth( data.Health or 50 )
    
    npc:setDamageMultiplier( NPC.DamageMultiplier * (data.Damage or 1) )
    npc:setWeaponProficiency( data.Proficiency or NPC.WeaponProficiency )
    
    if data.Scale then
        timer.simple(0, function()
            npc:setScale( data.Scale )
        end)
    end
    
    if data.Color then
        npc:setMaterial(data.Color)
    end
    
    if data.Material then
        npc:setMaterial(data.Material)
    end
    
    
    if data.Abilities then
        for i,v in pairs(data.Abilities) do
            timer.simple(math.random()*v.Cooldown, function()
                timer.create("Entity" .. npc:entIndex() .. "_Ability" .. i, v.Cooldown, 0, function()
                    coroutine.wrap(v.Use)( npc )
                end)
            end)
        end
    end
    
    
    for i,v in pairs(find.allPlayers()) do
        npc:addEntityRelationship( v, NPC.shouldParticipate( v ) and "hate" or "like", 0 )
    end
    
    
    -- Debug ESP
    if NPC.Debug then
        pcall(function()
            local mk = hologram.create( npc:getPos(), Angle(), "models/props_c17/canister01a.mdl" )
            mk:setParent(npc)
        end)
    end
    
    if squadLeader then
        npc:setGlobalSquad( "sb_squad_" .. tostring(squadLeader:entIndex()) )
    elseif data.Squad then
        npc:setGlobalSquad( "sb_squad_" .. tostring(npc:entIndex()) )
        
        local queue = {}
        
        for i,v in pairs( data.Squad ) do
            local count = v[3] and math.random(v[2], v[3]) or v[2]
            local id = v[1]
            
            for i=1, count do
                table.insert(queue, math.random(#queue), id)
            end
        end
        
        
        local r = 24 + #queue * 4
        
        for i,v in pairs(queue) do
            local a = i/#queue * 2 * math.pi
            local pos = npc:getPos() + Vector( math.cos(a)*r, math.sin(a)*r, 0 )
            
            Spawner.Enqueue(function()
                if not npc:isValid() then return end
                
                local ground = trace.line( pos + Vector(0,0,72), pos - Vector(0,0,72) )
                if not ground.Hit or ground.HitNonWorld or ground.HitNoDraw then return end
                
                NPC.spawn( ground.HitPos + Vector(0,0,8), v, npc )
            end)
        end
    end
    
    return npc
end







-- Interact with doors

local DoorInteractables = {}
local DoorLookup = {}

do
    local WorldEnts = find.all(function(e)
        return not isValid(e:getOwner())
    end)
    
    for i,v in pairs(WorldEnts) do
        if v:getClass() == "func_button" or v:getClass() == "func_door" then
            table.insert(DoorInteractables, v)
            DoorLookup[v] = true
        end
    end
end



timer.create("Interact", 3, 0, function()
    if #NPC.Instances == 0 then return end
    
    local interacted = {}
    
    for i=1, math.ceil(#NPC.Instances*0.6) do
        local v = table.random(NPC.Instances)
        if not v:getEnemy() then continue end
        
        local interactables = find.inSphere( v:getEyePos(), 200, function(e)
            return DoorLookup[e]
        end)
        
        for i,v in pairs(interactables) do
            if interacted[v] then continue end
            
            interacted[v] = true
            v:use()
        end
    end
end)


timer.create("despawn", 1, 0, function()
    for i,v in pairs(NPC.Instances) do
        if v:getEnemy() then
            v.LastSighted = timer.curtime()
        elseif timer.curtime() - v.LastSighted > NPC.DespawnTime then
            v:remove()
        end
    end
end)


-- idk why these dont get cleaned up automatically
hook.add("EntityTakeDamage", "CeilingTurretCleanup", function( victim, attacker, inflictor, amount )
    if not victim:isNPC() then return end
    if not victim.IsChipNPC then return end
    
    if victim:getHealth() - amount <= 0 then
        if victim:getClass() == "npc_turret_ceiling" then
            timer.simple(1, function()
                if not isValid(victim) then return end
                
                victim:remove()
            end)
        end
    end
end)





hook.add("EntityRemoved", "deleteCombine", function(e)
    if not e:isNPC() then return end
    if not e.IsChipNPC then return end
    
    table.removeByValue(NPC.Instances, e)
    
    local data = NPC.Types[e.ID]
    
    if data.Abilities then
        for i,v in pairs(data.Abilities) do
            timer.stop("Entity" .. e:entIndex() .. "_Ability" .. i)
        end
    end
end)



--[[
hook.add("PlayerEnterPvp", "relationship", function( plr )
    for i,npc in pairs(NPC.Instances) do
        npc:addEntityRelationship( plr, "hate", 0 )
    end
end)



hook.add("PlayerExitPvp", "relationship", function( plr )
    for i,npc in pairs(NPC.Instances) do
        npc:addEntityRelationship( plr, "like", 0 )
    end
end)
]]



--[[ Relationship manager ]]--

function updatePlayingStatus(plr)
    local playing = NPC.shouldParticipate( plr )
    local wasPlaying = table.hasValue( NPC.Participants, plr )
    if playing == wasPlaying then return end
    
    if playing then
        table.insert(NPC.Participants, plr)
    else
        table.removeByValue(NPC.Participants, plr)
    end
    
    for i,v in pairs(NPC.Instances) do
        v:addEntityRelationship( plr, playing and "hate" or "like", 0 )
    end
end




timer.create("UpdateParticipants", 0.5, 0, function()
    for i,v in pairs(find.allPlayers()) do
        updatePlayingStatus(v)
    end
end)


hook.add("PlayerEnterPvp", "", updatePlayingStatus)
hook.add("PlayerExitPvp", "", updatePlayingStatus)









return NPC